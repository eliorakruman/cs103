"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSnapshotFromFile = exports.parseSnapshot = void 0;
const oboe = require("oboe");
const fs = require("fs");
function hasDetachedness(data) {
    return data.snapshot.meta.node_fields.length == 7;
}
function nodeFieldCount(data) {
    return hasDetachedness(data) ? 7 : 6;
}
const EdgeFieldCount = 3;
const nodeTypeTypes = ["hidden", "array", "string", "object", "code", "closure", "regexp", "number", "native", "synthetic", "concatenated string", "sliced string", "symbol", "bigint"];
const metaDataWithoutDetachedness = {
    "node_fields": ["type", "name", "id", "self_size", "edge_count", "trace_node_id"],
    "node_types": [nodeTypeTypes, "string", "number", "number", "number", "number"],
    "edge_fields": ["type", "name_or_index", "to_node"],
    "edge_types": [["context", "element", "property", "internal", "hidden", "shortcut", "weak"], "string_or_number", "node"],
    "trace_function_info_fields": ["function_id", "name", "script_name", "script_id", "line", "column"],
    "trace_node_fields": ["id", "function_info_index", "count", "size", "children"],
    "sample_fields": ["timestamp_us", "last_assigned_id"],
    "location_fields": ["object_index", "script_id", "line", "column"],
};
{
    let checkNodeTypes = metaDataWithoutDetachedness.node_types[0][0];
    let checkEdgeTypes = metaDataWithoutDetachedness.edge_types[0][0];
    checkNodeTypes;
    checkEdgeTypes;
}
const metaDataWithDetachedness = {
    "node_fields": ["type", "name", "id", "self_size", "edge_count", "trace_node_id", "detachedness"],
    "node_types": [nodeTypeTypes, "string", "number", "number", "number", "number", "number"],
    "edge_fields": ["type", "name_or_index", "to_node"],
    "edge_types": [["context", "element", "property", "internal", "hidden", "shortcut", "weak"], "string_or_number", "node"],
    "trace_function_info_fields": ["function_id", "name", "script_name", "script_id", "line", "column"],
    "trace_node_fields": ["id", "function_info_index", "count", "size", "children"],
    "sample_fields": ["timestamp_us", "last_assigned_id"],
    "location_fields": ["object_index", "script_id", "line", "column"],
};
{
    let checkNodeTypes = metaDataWithDetachedness.node_types[0][0];
    let checkEdgeTypes = metaDataWithDetachedness.edge_types[0][0];
    checkNodeTypes;
    checkEdgeTypes;
}
function metaData(data) {
    return hasDetachedness(data) ? metaDataWithDetachedness : metaDataWithoutDetachedness;
}
let warnedAboutChangedHeapFormat = false;
function sanityCheck(data) {
    function check(ok) {
        if (!ok && !warnedAboutChangedHeapFormat) {
            warnedAboutChangedHeapFormat = true;
            console.error("Heapsnapshot format changed! Please report to https://github.com/SrTobi/v8-heapsnapshot/issues");
        }
    }
    check(data);
    check(Array.isArray(data.nodes));
    check(Array.isArray(data.edges));
    check(Array.isArray(data.strings));
    check(Array.isArray(data.trace_function_infos));
    check(Array.isArray(data.trace_tree));
    check(Array.isArray(data.samples));
    const ss = data.snapshot;
    check(Number.isInteger(ss.node_count));
    check(Number.isInteger(ss.edge_count));
    check(Number.isInteger(ss.trace_function_count));
    check(ss.meta);
    const meta = ss.meta;
    check(JSON.stringify(meta) === JSON.stringify(metaData(data)));
    check(meta.node_fields.length == nodeFieldCount(data));
    check(meta.edge_fields.length == EdgeFieldCount);
    check(ss.node_count * meta.node_fields.length == data.nodes.length);
    check(ss.edge_count * meta.edge_fields.length == data.edges.length);
    check(ss.trace_function_count * meta.trace_function_info_fields.length == data.trace_function_infos.length);
}
class NodeImpl {
    constructor(type, name, id, self_size, edge_count, trace_node_id, detached) {
        this.type = type;
        this.name = name;
        this.id = id;
        this.self_size = self_size;
        this.edge_count = edge_count;
        this.trace_node_id = trace_node_id;
        this.detached = detached;
        this.out_edges = [];
        this.in_edges = [];
    }
    toString() {
        return `${this.name}[${this.type}]@${this.id}`;
    }
    toLongString() {
        return `${this.name}[${this.type}]@${this.id}{${this.out_edges.join(", ")}}`;
    }
    print(deep = 2, indent = 0, edge_prefix) {
        console.log("|" + Array(indent + 1).join("  ") + (edge_prefix || "") + this.toString());
        if (deep > 0) {
            for (const e of this.out_edges) {
                e.to.print(deep - 1, indent + 1, `[${e.type}]${e.name} -> `);
            }
        }
    }
}
class EdgeImpl {
    constructor(type, name, from, to) {
        this.type = type;
        this.name = name;
        this.from = from;
        this.to = to;
    }
    toString() {
        return `[${this.type}]${this.name} -> ${this.to}`;
    }
    toLongString() {
        return `[${this.type}]${this.name} -> ${this.to.toLongString()}`;
    }
}
class SnapshotImpl {
    constructor(nodes, edges, hasDetachedness) {
        this.nodes = nodes;
        this.edges = edges;
        this.hasDetachedness = hasDetachedness;
        this.idToNodeMapping = new Map();
        nodes.forEach(node => this.idToNodeMapping.set(node.id, node));
    }
    findNodeById(id) {
        return this.idToNodeMapping.get(id);
    }
    get global() {
        if (!this._global) {
            this._global = this.nodes.find(node => node.name === "global / ");
            if (!this._global) {
                throw new Error("Could not find global object!");
            }
        }
        return this._global;
    }
    get modules() {
        if (!this._modules) {
            this._modules = this.nodes.filter(node => node.name === "Module" && node.type === "object");
        }
        return this._modules;
    }
}
function parseNodes(data) {
    const nodes = data.nodes;
    const strings = data.strings;
    const types = metaData(data).node_types[0];
    const result = [];
    const hasDetachedness_ = hasDetachedness(data);
    const nodeFieldCount_ = nodeFieldCount(data);
    for (let nodeIndex = 0; nodeIndex < data.snapshot.node_count; ++nodeIndex) {
        let dataIndex = nodeIndex * nodeFieldCount_;
        const node = new NodeImpl(types[nodes[dataIndex++]], strings[nodes[dataIndex++]], nodes[dataIndex++], nodes[dataIndex++], nodes[dataIndex++], nodes[dataIndex++], hasDetachedness_ ? (nodes[dataIndex++] == 1) : undefined);
        result.push(node);
    }
    return result;
}
function parseAndWireEdges(data, nodes) {
    const result = [];
    const edges = data.edges;
    const strings = data.strings;
    const types = metaDataWithoutDetachedness.edge_types[0];
    function name_or_index(type, i) {
        if (type == "element" || type == "hidden") {
            return i;
        }
        if (i >= strings.length) {
            throw new Error("Invalid string index!");
        }
        return strings[i];
    }
    const nodeFieldCount_ = nodeFieldCount(data);
    let edgeIndex = 0;
    nodes.forEach((from_node, nodeIndex) => {
        for (let edgeCount = 0; edgeCount < from_node.edge_count; ++edgeCount) {
            const type = types[edges[edgeIndex++]];
            const name = name_or_index(type, edges[edgeIndex++]);
            const to_node = nodes[edges[edgeIndex++] / nodeFieldCount_];
            const edge = new EdgeImpl(type, name, from_node, to_node);
            result.push(edge);
            from_node.out_edges.push(edge);
            to_node.in_edges.push(edge);
        }
    });
    return result;
}
function parseSnapshot(arg1) {
    return __awaiter(this, void 0, void 0, function* () {
        let data;
        if (typeof arg1 === "string") {
            data = JSON.parse(arg1);
        }
        else if (arg1 instanceof fs.ReadStream) {
            data = yield new Promise((resolve, reject) => {
                oboe(arg1)
                    .node("!", resolve)
                    .fail(reject);
            });
        }
        else if (typeof arg1 === "object") {
            data = arg1;
        }
        else {
            throw new Error("Illigal snapshot data!");
        }
        sanityCheck(data);
        const nodes = parseNodes(data);
        const edges = parseAndWireEdges(data, nodes);
        return new SnapshotImpl(nodes, edges, hasDetachedness(data));
    });
}
exports.parseSnapshot = parseSnapshot;
function parseSnapshotFromFile(filename, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const stream = fs.createReadStream(filename, options);
        return yield parseSnapshot(stream);
    });
}
exports.parseSnapshotFromFile = parseSnapshotFromFile;
/*

async function main() {
    const snapshot = await parseSnapshotFromFile(process.argv[2] || "blub.js.heapsnapshot")
    console.log("nodes:", snapshot.nodes.length)
    console.log("edges:", snapshot.edges.length)

    debugger;
}

main()

*/
//# sourceMappingURL=index.js.map